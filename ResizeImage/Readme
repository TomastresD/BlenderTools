Conversación con Gemini 25/08/2025
Script para Escalar la Imagen
Este script se encargará de encontrar la imagen en la textura del material de tu plano, reescalarla a 4096x4096 píxeles y luego guardar la imagen con el nuevo tamaño.

Python

import bpy

# Definimos el tamaño deseado para la imagen
new_size = (4096, 4096)

# 1. Encontrar el plano y su material (ajusta estos nombres si son diferentes)
# Asume que el objeto activo es el plano que genera el addon
obj = bpy.context.active_object

# Asegúrate de que el objeto es un 'MESH' y tiene un material
if obj and obj.type == 'MESH' and obj.data.materials:
    # 2. Acceder al material del objeto
    material = obj.data.materials[0]
    
    # 3. Encontrar el nodo de textura de imagen
    if material.use_nodes:
        # Busca el nodo de tipo 'ShaderNodeTexImage'
        image_node = material.node_tree.nodes.get("Image Texture")
        
        if image_node and image_node.image:
            # 4. Obtener la imagen
            image = image_node.image
            
            # 5. Reescalar la imagen en memoria
            image.scale(new_size[0], new_size[1])
            
            # 6. Opcional: Guardar la imagen reescalada en un archivo
            # Esto es crucial para que los cambios se mantengan fuera de Blender
            # Asegúrate de cambiar 'C:/temp/scaled_image.png' por la ruta y nombre de archivo que desees
            try:
                # Usa un nombre de archivo temporal para evitar sobrescribir el original
                # y un formato de archivo que soporte transparencia si es necesario
                scaled_filepath = '//scaled_' + image.name
                image.save_render(filepath=scaled_filepath)
                print(f"Imagen '{image.name}' reescalada a {new_size[0]}x{new_size[1]} y guardada como '{scaled_filepath}'")
            except Exception as e:
                print(f"Error al guardar la imagen: {e}")
        else:
            print("No se encontró el nodo de textura de imagen o no tiene una imagen asignada.")
    else:
        print("El material no utiliza nodos.")
else:
    print("El objeto activo no es un MESH o no tiene un material.")

Cómo Usar el Script
Abre el Editor de Texto en Blender (cambia una de las ventanas a este modo).

Haz clic en "New" para crear un nuevo script.

Copia y pega el código anterior en el editor.

Asegúrate de tener seleccionado el plano que el addon acaba de generar en tu escena 3D.

Haz clic en el botón "Run Script" (el ícono del triángulo) en la parte superior del editor de texto.

El script buscará la imagen asociada al material del objeto seleccionado, la reescalará a 4096x4096 píxeles y la guardará en un archivo con el nombre scaled_<nombre_original_de_la_imagen>.png en la misma carpeta que tu archivo .blend.

Nota: La línea obj = bpy.context.active_object asume que el plano que quieres modificar es el último que seleccionaste. Si el addon te deja con el plano seleccionado, este método funcionará a la perfección. De lo contrario, tendrías que ajustar la línea para referenciar el plano por su nombre, por ejemplo: obj = bpy.data.objects['NombreDeTuPlano'].






puedo cambiar la ruta a, por ejemplo, E:\


Sí, puedes cambiar la ruta de guardado a E:\ o a cualquier otra carpeta. Solo necesitas modificar la línea que define la ruta del archivo en el script.

Script para Escalar y Guardar la Imagen
Para guardar la imagen reescalada en la raíz del disco E:\, solo tienes que ajustar la variable scaled_filepath.

Python

import bpy
import os

# Definimos el tamaño deseado para la imagen
new_size = (4096, 4096)

# Definimos la ruta de la carpeta donde se guardará la imagen
# Asegúrate de que esta carpeta exista, de lo contrario, el script dará error.
output_folder = "E:\\"

# 1. Encontrar el plano y su material (ajusta estos nombres si son diferentes)
obj = bpy.context.active_object

if obj and obj.type == 'MESH' and obj.data.materials:
    material = obj.data.materials[0]
    
    if material.use_nodes:
        image_node = material.node_tree.nodes.get("Image Texture")
        
        if image_node and image_node.image:
            image = image_node.image
            
            # 2. Reescalar la imagen en memoria
            image.scale(new_size[0], new_size[1])
            
            # 3. Construir la ruta completa del archivo de salida
            # El nombre del archivo será 'scaled_' + el nombre original de la imagen
            scaled_filename = 'scaled_' + image.name
            scaled_filepath = os.path.join(output_folder, scaled_filename)

            # 4. Guardar la imagen reescalada
            try:
                # El método save_render() guarda la imagen con el nuevo tamaño
                image.save_render(filepath=scaled_filepath)
                print(f"Imagen '{image.name}' reescalada a {new_size[0]}x{new_size[1]} y guardada en '{scaled_filepath}'")
            except Exception as e:
                print(f"Error al guardar la imagen. Asegúrate de que la ruta '{output_folder}' exista y tengas permisos de escritura.")
                print(f"Error: {e}")
        else:
            print("No se encontró el nodo de textura de imagen o no tiene una imagen asignada.")
    else:
        print("El material no utiliza nodos.")
else:
    print("El objeto activo no es un MESH o no tiene un material.")

Consideraciones Importantes
Ruta de la Carpeta: La línea output_folder = "E:\\" usa una doble barra invertida (\\) porque la barra invertida es un carácter de escape en Python. Usar una sola barra inclinada (/) también funcionaría en Windows.

Permisos y Existencia: El script no creará la carpeta por ti. Asegúrate de que la carpeta de destino (E:\ en este caso) ya exista y de que tu usuario tenga los permisos necesarios para escribir archivos en ella.

Nombre del Archivo: El nombre del archivo de salida se construye automáticamente con el prefijo scaled_ para evitar sobrescribir el archivo original. Esto es una buena práctica para no perder datos.






Perfecto. Como puedo usar este script como si fuera un addon?


Para usar el script como un addon, debes crear una estructura de archivo y un encabezado de script específicos para que Blender pueda reconocerlo e instalarlo como un complemento.

Paso 1: Crea el Archivo del Addon
Abre el Editor de Texto en Blender.

Copia y pega el siguiente código. Este es el script que hemos modificado, pero ahora con la estructura y el bl_info que lo convierten en un addon.

Python

bl_info = {
    "name": "Image Scaler",
    "author": "Tu Nombre",
    "version": (1, 0),
    "blender": (4, 1, 0),
    "location": "Viewport > Sidebar > Tools",
    "description": "Escala la textura del objeto activo a 4096x4096 y la guarda.",
    "warning": "",
    "wiki_url": "",
    "category": "Object",
}

import bpy
import os

class OBJECT_OT_scale_and_save_image(bpy.types.Operator):
    """Escala la imagen del objeto activo y la guarda."""
    bl_idname = "object.scale_and_save_image"
    bl_label = "Escalar y Guardar Imagen"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        new_size = (4096, 4096)
        output_folder = "E:\\"
        
        obj = context.active_object
        
        if not obj or obj.type != 'MESH' or not obj.data.materials:
            self.report({'WARNING'}, "El objeto activo no es un MESH o no tiene un material.")
            return {'CANCELLED'}

        material = obj.data.materials[0]
        
        if not material.use_nodes:
            self.report({'WARNING'}, "El material no usa nodos.")
            return {'CANCELLED'}

        image_node = material.node_tree.nodes.get("Image Texture")
        
        if not image_node or not image_node.image:
            self.report({'WARNING'}, "No se encontró el nodo de textura de imagen o no tiene una imagen asignada.")
            return {'CANCELLED'}

        image = image_node.image
        
        try:
            image.scale(new_size[0], new_size[1])
            
            scaled_filename = f'scaled_{image.name}'
            scaled_filepath = os.path.join(output_folder, scaled_filename)
            
            # Asegúrate de que la ruta de guardado sea un path absoluto
            if not os.path.isabs(scaled_filepath):
                scaled_filepath = bpy.path.abspath(scaled_filepath)
            
            # Guardar la imagen reescalada
            image.save_render(filepath=scaled_filepath)
            self.report({'INFO'}, f"Imagen '{image.name}' reescalada y guardada en '{scaled_filepath}'")
            return {'FINISHED'}
        except Exception as e:
            self.report({'ERROR'}, f"Error al guardar la imagen: {e}")
            return {'CANCELLED'}

def menu_func(self, context):
    self.layout.operator(OBJECT_OT_scale_and_save_image.bl_idname)

def register():
    bpy.utils.register_class(OBJECT_OT_scale_and_save_image)
    bpy.types.VIEW3D_MT_object.append(menu_func)

def unregister():
    bpy.utils.unregister_class(OBJECT_OT_scale_and_save_image)
    bpy.types.VIEW3D_MT_object.remove(menu_func)

if __name__ == "__main__":
    register()
Ve al menú Text en la parte superior del editor de texto y selecciona Save As....

Guarda el archivo en tu disco duro con el nombre image_scaler.py.

Paso 2: Instala el Addon en Blender
Abre Blender y ve a Edit > Preferences.

Haz clic en la pestaña Add-ons.

Haz clic en el botón Install... en la parte superior.

Navega hasta la ubicación donde guardaste el archivo image_scaler.py y selecciónalo.

Una vez instalado, el addon aparecerá en la lista. Búscalo (puedes usar el buscador) y marca la casilla de verificación para activarlo.

Paso 3: Usa el Addon
Selecciona el plano con la textura en tu escena 3D.

Haz clic derecho sobre el objeto.

En el menú contextual, ve a Object Context Menu > Scale and Save Image.

Con esto, el script se ejecutará automáticamente, escalando la imagen y guardándola en la ruta especificada. ¡Ahora puedes usarlo como una herramienta integrada en tu flujo de trabajo de Blender!






En que formato está guardando la imagen¿


El script está guardando la imagen en formato PNG.

La función image.save_render(filepath=scaled_filepath) de Blender guarda la imagen en el mismo formato que el archivo original. En el script de ejemplo, el nombre del archivo se construye con la extensión .png de la siguiente manera:

scaled_filename = 'scaled_' + image.name

Si la imagen original se llamaba imagen_satelite.jpg, el script intentará guardarla como scaled_imagen_satelite.jpg, pero el formato de guardado real lo determina el archivo original. Es una buena práctica asegurarse de que el nombre del archivo de salida tenga una extensión que corresponda al formato en el que quieres guardar la imagen.

Puedes ser más explícito con el formato ajustando la línea de código para que siempre guarde en PNG.

Python

# ...
scaled_filename = f'scaled_{image.name}.png'
scaled_filepath = os.path.join(output_folder, scaled_filename)

try:
    image.save_render(filepath=scaled_filepath)
# ...
De esta forma, te aseguras de que el formato de salida sea siempre PNG, un formato ideal para la mayoría de las texturas en 3D.






Si el tema es que el script ahora no guarda ni png ni ninguna otra extensión


Parece que hay un malentendido sobre cómo funciona la función save_render(). El problema no es que el script no esté guardando en un formato, sino que no tiene la información necesaria para hacerlo correctamente.

El Problema
Cuando usas image.save_render(filepath=...), Blender usa la extensión del nombre del archivo en el filepath para determinar el formato de guardado. Si el nombre de tu archivo es simplemente scaled_nombre_imagen, sin una extensión (como .png o .jpg), Blender no sabe qué formato usar y el comando falla.

La Solución
Para arreglarlo, debes asegurarte de que el nombre del archivo de salida siempre tenga la extensión de formato que deseas. La forma más segura de hacerlo es usando la función os.path.splitext para separar la extensión del nombre del archivo original y luego añadir la que tú elijas.

Script Mejorado para Guardar la Imagen
Este script te da un control total sobre el formato de salida, guardando siempre en PNG.

Python

bl_info = {
    "name": "Image Scaler",
    "author": "Tu Nombre",
    "version": (1, 0),
    "blender": (4, 1, 0),
    "location": "Viewport > Sidebar > Tools",
    "description": "Escala la textura del objeto activo a 4096x4096 y la guarda como PNG.",
    "warning": "",
    "wiki_url": "",
    "category": "Object",
}

import bpy
import os

class OBJECT_OT_scale_and_save_image(bpy.types.Operator):
    """Escala la imagen del objeto activo y la guarda."""
    bl_idname = "object.scale_and_save_image"
    bl_label = "Escalar y Guardar Imagen (PNG)"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        new_size = (4096, 4096)
        output_folder = "E:\\"
        
        obj = context.active_object
        
        if not obj or obj.type != 'MESH' or not obj.data.materials:
            self.report({'WARNING'}, "El objeto activo no es un MESH o no tiene un material.")
            return {'CANCELLED'}

        material = obj.data.materials[0]
        
        if not material.use_nodes:
            self.report({'WARNING'}, "El material no usa nodos.")
            return {'CANCELLED'}

        image_node = material.node_tree.nodes.get("Image Texture")
        
        if not image_node or not image_node.image:
            self.report({'WARNING'}, "No se encontró el nodo de textura de imagen o no tiene una imagen asignada.")
            return {'CANCELLED'}

        image = image_node.image
        
        try:
            image.scale(new_size[0], new_size[1])
            
            # Obtiene el nombre del archivo original sin la extensión
            original_filename_no_ext = os.path.splitext(image.name)[0]
            # Construye el nuevo nombre de archivo con la extensión .png
            scaled_filename = f'scaled_{original_filename_no_ext}.png'
            scaled_filepath = os.path.join(output_folder, scaled_filename)

            # Si el path es relativo, lo convierte a absoluto
            if not os.path.isabs(scaled_filepath):
                scaled_filepath = bpy.path.abspath(scaled_filepath)
            
            # Asegúrate de que el formato de imagen de salida en Blender sea PNG
            context.scene.render.image_settings.file_format = 'PNG'

            # Guarda la imagen reescalada
            image.save_render(filepath=scaled_filepath)
            self.report({'INFO'}, f"Imagen '{image.name}' reescalada y guardada en '{scaled_filepath}'")
            return {'FINISHED'}
        except Exception as e:
            self.report({'ERROR'}, f"Error al guardar la imagen: {e}")
            return {'CANCELLED'}

def menu_func(self, context):
    self.layout.operator(OBJECT_OT_scale_and_save_image.bl_idname)

def register():
    bpy.utils.register_class(OBJECT_OT_scale_and_save_image)
    bpy.types.VIEW3D_MT_object.append(menu_func)

def unregister():
    bpy.utils.unregister_class(OBJECT_OT_scale_and_save_image)
    bpy.types.VIEW3D_MT_object.remove(menu_func)

if __name__ == "__main__":
    register()
¿Qué ha cambiado?
Hemos importado el módulo os.

La línea scaled_filename = f'scaled_{image.name}' ha sido reemplazada por:

original_filename_no_ext = os.path.splitext(image.name)[0]: Esta línea toma el nombre de la imagen y le quita la extensión. Por ejemplo, si la imagen se llama mapa_satelite.jpg, esta variable contendrá mapa_satelite.

scaled_filename = f'scaled_{original_filename_no_ext}.png': Luego, se construye el nuevo nombre del archivo, añadiendo el prefijo y la extensión .png al final, asegurando que el nombre del archivo siempre sea válido.

Se ha añadido la línea context.scene.render.image_settings.file_format = 'PNG' para asegurarse de que Blender use el formato PNG al guardar la imagen.

Guarda este nuevo código como image_scaler.py, vuelve a instalar el addon en Blender y pruébalo de nuevo. Con estos cambios, el script debe guardar el archivo correctamente en formato PNG.






Pero yo no quiero forzar a ponerle extensión PNG. Además entiendo que si la imagen original no es PNG podría dar problemas, no?


Entiendo. Quieres que el script sea más flexible y guarde la imagen en el mismo formato que la imagen original, sin forzar una extensión específica. Y tienes razón: forzar un formato como PNG en una imagen que podría ser JPG podría causar problemas de compatibilidad o pérdida de calidad.

Aquí tienes una versión del script que guarda la imagen en el mismo formato que la original.

Script Mejorado para Guardar la Imagen
Este script ahora:

Obtiene el nombre y la extensión del archivo de imagen original.

Construye el nuevo nombre de archivo manteniendo la extensión original.

Establece el formato de archivo de guardado en Blender para que coincida con el formato de la imagen original.

Python

bl_info = {
    "name": "Image Scaler",
    "author": "Tu Nombre",
    "version": (1, 0),
    "blender": (4, 1, 0),
    "location": "Viewport > Sidebar > Tools",
    "description": "Escala la textura del objeto activo y la guarda con el mismo formato original.",
    "warning": "",
    "wiki_url": "",
    "category": "Object",
}

import bpy
import os

class OBJECT_OT_scale_and_save_image(bpy.types.Operator):
    """Escala la imagen del objeto activo y la guarda."""
    bl_idname = "object.scale_and_save_image"
    bl_label = "Escalar y Guardar Imagen (Formato Original)"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        new_size = (4096, 4096)
        output_folder = "E:\\"
        
        obj = context.active_object
        
        if not obj or obj.type != 'MESH' or not obj.data.materials:
            self.report({'WARNING'}, "El objeto activo no es un MESH o no tiene un material.")
            return {'CANCELLED'}

        material = obj.data.materials[0]
        
        if not material.use_nodes:
            self.report({'WARNING'}, "El material no usa nodos.")
            return {'CANCELLED'}

        image_node = material.node_tree.nodes.get("Image Texture")
        
        if not image_node or not image_node.image:
            self.report({'WARNING'}, "No se encontró el nodo de textura de imagen o no tiene una imagen asignada.")
            return {'CANCELLED'}

        image = image_node.image
        
        try:
            image.scale(new_size[0], new_size[1])
            
            # Obtiene el nombre del archivo y la extensión por separado
            original_filename, original_ext = os.path.splitext(image.name)
            
            # Construye el nuevo nombre de archivo, manteniendo la extensión original
            scaled_filename = f'scaled_{original_filename}{original_ext}'
            scaled_filepath = os.path.join(output_folder, scaled_filename)

            # Si el path es relativo, lo convierte a absoluto
            if not os.path.isabs(scaled_filepath):
                scaled_filepath = bpy.path.abspath(scaled_filepath)
            
            # Establece el formato de guardado de Blender basado en la extensión
            image_format = original_ext.lstrip('.').upper()
            context.scene.render.image_settings.file_format = image_format
            
            # Guarda la imagen reescalada
            image.save_render(filepath=scaled_filepath)
            self.report({'INFO'}, f"Imagen '{image.name}' reescalada y guardada en '{scaled_filepath}'")
            return {'FINISHED'}
        except Exception as e:
            self.report({'ERROR'}, f"Error al guardar la imagen: {e}")
            return {'CANCELLED'}

def menu_func(self, context):
    self.layout.operator(OBJECT_OT_scale_and_save_image.bl_idname)

def register():
    bpy.utils.register_class(OBJECT_OT_scale_and_save_image)
    bpy.types.VIEW3D_MT_object.append(menu_func)

def unregister():
    bpy.utils.unregister_class(OBJECT_OT_scale_and_save_image)
    bpy.types.VIEW3D_MT_object.remove(menu_func)

if __name__ == "__main__":
    register()
Cambios Clave
Obtención de Extensión: La línea original_filename, original_ext = os.path.splitext(image.name) separa el nombre del archivo de su extensión. Por ejemplo, de imagen.jpg obtendrás 'imagen' y '.jpg'.

Nombre de Archivo Dinámico: El nuevo nombre del archivo se construye con la misma extensión original: scaled_filename = f'scaled_{original_filename}{original_ext}'.

Formato de Guardado: Se añade la línea context.scene.render.image_settings.file_format = image_format, que lee la extensión (.jpg, .png, etc.), le quita el punto, la convierte a mayúsculas (JPG, PNG, etc.) y se lo pasa a Blender para que sepa en qué formato guardar. Esto asegura que Blender guarde la imagen correctamente, ya sea PNG, JPG o cualquier otro formato que reconozca.

Con este script, no tendrás que preocuparte por el formato de la imagen original; el addon se encargará de guardar la nueva versión de manera segura.






Creo que el problema es que la imagen original no tiene ninguna extensión de formato. Pero lo suyo es entender que extensión de formato tiene o está aplicando el script para evitar errores de compatibilidad



Si la imagen original no tiene extensión de archivo, el script no podrá determinar su formato, lo que provoca el error. El addon de Blender-GIS a veces descarga las imágenes sin una extensión, ya que su formato se maneja internamente.

El script que te proporcioné necesita la extensión de archivo para saber qué formato usar al guardar. Sin ella, os.path.splitext no puede obtener una extensión, y el código para establecer el formato de imagen (context.scene.render.image_settings.file_format = image_format) falla porque image_format queda vacío o es incorrecto.

Solución
Para solucionar esto, el script debe intentar determinar el formato de la imagen de forma alternativa. Un método común es obtenerlo directamente de las propiedades de la imagen en Blender.

Aquí tienes un script que mejora el anterior para manejar este caso. Primero, comprueba si la imagen tiene una extensión de archivo. Si no, usa el formato de archivo de imagen de Blender para determinar la extensión correcta antes de guardar.

Python

import bpy
import os

bl_info = {
    "name": "Image Scaler",
    "author": "Tu Nombre",
    "version": (1, 0),
    "blender": (4, 1, 0),
    "location": "Viewport > Sidebar > Tools",
    "description": "Escala la textura del objeto activo y la guarda con el mismo formato original.",
    "warning": "",
    "wiki_url": "",
    "category": "Object",
}

class OBJECT_OT_scale_and_save_image(bpy.types.Operator):
    """Escala la imagen del objeto activo y la guarda."""
    bl_idname = "object.scale_and_save_image"
    bl_label = "Escalar y Guardar Imagen (Formato Original)"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        new_size = (4096, 4096)
        # Asegúrate de que esta carpeta exista y tengas permisos.
        output_folder = "E:\\"
        
        obj = context.active_object
        
        if not obj or obj.type != 'MESH' or not obj.data.materials:
            self.report({'WARNING'}, "El objeto activo no es un MESH o no tiene un material.")
            return {'CANCELLED'}

        material = obj.data.materials[0]
        
        if not material.use_nodes:
            self.report({'WARNING'}, "El material no usa nodos.")
            return {'CANCELLED'}

        image_node = material.node_tree.nodes.get("Image Texture")
        
        if not image_node or not image_node.image:
            self.report({'WARNING'}, "No se encontró el nodo de textura de imagen o no tiene una imagen asignada.")
            return {'CANCELLED'}

        image = image_node.image
        
        try:
            image.scale(new_size[0], new_size[1])
            
            # Obtiene el nombre y la extensión del archivo.
            original_filename, original_ext = os.path.splitext(image.name)
            
            # Si no hay extensión en el nombre, la determina a partir del formato de Blender.
            if not original_ext:
                # Usa el formato interno de Blender para la imagen
                blender_image_format = image.file_format.lower()
                
                # Mapeo de formatos comunes a extensiones
                format_map = {
                    'tga': '.tga', 'jpeg': '.jpg', 'bmp': '.bmp',
                    'png': '.png', 'tiff': '.tif', 'open_exr': '.exr'
                }
                
                original_ext = format_map.get(blender_image_format, '.png')
                
                self.report({'INFO'}, f"La imagen no tiene extensión. Se usará el formato detectado: {blender_image_format.upper()} ({original_ext})")

            # Construye el nuevo nombre de archivo, manteniendo la extensión original o la detectada.
            scaled_filename = f'scaled_{original_filename}{original_ext}'
            scaled_filepath = os.path.join(output_folder, scaled_filename)

            # Si el path es relativo, lo convierte a absoluto
            if not os.path.isabs(scaled_filepath):
                scaled_filepath = bpy.path.abspath(scaled_filepath)
            
            # Establece el formato de guardado de Blender basado en la extensión
            image_format = original_ext.lstrip('.').upper()
            context.scene.render.image_settings.file_format = image_format
            
            # Guarda la imagen reescalada
            image.save_render(filepath=scaled_filepath)
            self.report({'INFO'}, f"Imagen '{image.name}' reescalada y guardada en '{scaled_filepath}'")
            return {'FINISHED'}
        except Exception as e:
            self.report({'ERROR'}, f"Error al guardar la imagen: {e}")
            return {'CANCELLED'}

def menu_func(self, context):
    self.layout.operator(OBJECT_OT_scale_and_save_image.bl_idname)

def register():
    bpy.utils.register_class(OBJECT_OT_scale_and_save_image)
    bpy.types.VIEW3D_MT_object.append(menu_func)

def unregister():
    bpy.utils.unregister_class(OBJECT_OT_scale_and_save_image)
    bpy.types.VIEW3D_MT_object.remove(menu_func)

if __name__ == "__main__":
    register()
Cómo Funciona Este Nuevo Script:
El script intenta obtener la extensión del nombre de la imagen como antes.

Si original_ext está vacío (lo que significa que no había extensión en el nombre), el script accede a la propiedad image.file_format de Blender. Esta propiedad contiene el tipo de formato de la imagen cargada (por ejemplo, 'PNG', 'JPEG', 'TIFF').

Utiliza un mapeo simple para convertir el formato de Blender (jpeg, png, etc.) a la extensión de archivo correspondiente (.jpg, .png).

Con la extensión determinada, construye el nuevo nombre de archivo de forma segura y procede a guardar la imagen correctamente, ya que ahora siempre habrá una extensión.

Con este cambio, el addon será mucho más robusto y capaz de manejar imágenes sin extensión de nombre de archivo, lo cual es muy útil para el flujo de trabajo con addons como Blender-GIS.






Parece que el formato original de la imagen guardada por blender y el addon es Tiff


Genial, si el formato original de la imagen es TIFF, podemos asegurarnos de que el script lo maneje correctamente. El script que te proporcioné en la respuesta anterior ya está diseñado para detectar y utilizar el formato de la imagen original (image.file_format), lo que debería funcionar perfectamente para el caso de las imágenes TIFF.

Aquí tienes un recordatorio de cómo el script maneja este escenario:

El script comprueba el nombre del archivo de la imagen.

Si no encuentra una extensión (por ejemplo, el nombre es solo mapa_satelite), el script accede a la propiedad image.file_format de Blender.

En tu caso, esta propiedad debería devolver 'TIFF'.

El script usará esta información para construir un nombre de archivo con la extensión .tiff y configurará el formato de guardado de Blender a TIFF.

Verificación de la lógica del script
El script anterior incluye este bloque de código:

Python

blender_image_format = image.file_format.lower()
format_map = {
    'tga': '.tga', 'jpeg': '.jpg', 'bmp': '.bmp',
    'png': '.png', 'tiff': '.tif', 'open_exr': '.exr'
}
original_ext = format_map.get(blender_image_format, '.png')
Si el formato de archivo de la imagen es 'TIFF', blender_image_format será 'tiff'. La búsqueda en el diccionario format_map devolverá '.tif'. Por lo tanto, el archivo se guardará con la extensión .tif.

Si quieres que la extensión sea .tiff en lugar de .tif (aunque Blender las maneja indistintamente), puedes cambiar la línea del mapeo a:

'tiff': '.tiff'

El resto del script debería funcionar sin problemas, ya que la lógica está diseñada para ser flexible y adaptarse al formato original, incluso si no hay una extensión en el nombre del archivo. Con la corrección del mapeo, el script debería funcionar perfectamente con tus imágenes TIFF.






Y podría con el script convertir de Tiff a otro formato?


Sí, con el script podrías convertir una imagen TIFF a otro formato, como PNG o JPG, al momento de reescalarla y guardarla. Esto es muy útil si el formato TIFF no es el ideal para tu flujo de trabajo en Unity, ya que los formatos como PNG o JPG son más comunes para texturas y tienen mejor compresión.

Para lograrlo, solo necesitas modificar el script para que, en lugar de detectar y usar el formato original, fuerce el uso de un formato específico.

Script Modificado para Conversión de Formato
Este script hace dos cosas:

Escala la imagen del objeto activo a 4096x4096.

La guarda con la extensión y formato que tú definas, independientemente del formato original.

En este ejemplo, la imagen se convertirá a PNG.

Python

import bpy
import os

bl_info = {
    "name": "Image Scaler and Converter",
    "author": "Tu Nombre",
    "version": (1, 0),
    "blender": (4, 1, 0),
    "location": "Viewport > Sidebar > Tools",
    "description": "Escala la textura del objeto activo y la convierte a PNG.",
    "warning": "",
    "wiki_url": "",
    "category": "Object",
}

class OBJECT_OT_scale_and_convert_image(bpy.types.Operator):
    """Escala la imagen del objeto activo y la convierte a PNG."""
    bl_idname = "object.scale_and_convert_image"
    bl_label = "Escalar y Convertir a PNG"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        new_size = (4096, 4096)
        output_folder = "E:\\"
        
        # Formato y extensión de salida deseados
        output_format = 'PNG'
        output_ext = '.png'
        
        obj = context.active_object
        
        if not obj or obj.type != 'MESH' or not obj.data.materials:
            self.report({'WARNING'}, "El objeto activo no es un MESH o no tiene un material.")
            return {'CANCELLED'}

        material = obj.data.materials[0]
        
        if not material.use_nodes:
            self.report({'WARNING'}, "El material no usa nodos.")
            return {'CANCELLED'}

        image_node = material.node_tree.nodes.get("Image Texture")
        
        if not image_node or not image_node.image:
            self.report({'WARNING'}, "No se encontró el nodo de textura de imagen o no tiene una imagen asignada.")
            return {'CANCELLED'}

        image = image_node.image
        
        try:
            image.scale(new_size[0], new_size[1])
            
            # Obtiene el nombre del archivo sin la extensión original
            original_filename = os.path.splitext(image.name)[0]
            
            # Construye el nuevo nombre de archivo con la extensión deseada
            scaled_filename = f'scaled_{original_filename}{output_ext}'
            scaled_filepath = os.path.join(output_folder, scaled_filename)

            # Si el path es relativo, lo convierte a absoluto
            if not os.path.isabs(scaled_filepath):
                scaled_filepath = bpy.path.abspath(scaled_filepath)
            
            # Establece el formato de guardado de Blender a PNG
            context.scene.render.image_settings.file_format = output_format
            
            # Guarda la imagen reescalada y convertida
            image.save_render(filepath=scaled_filepath)
            self.report({'INFO'}, f"Imagen '{image.name}' reescalada y convertida a PNG, guardada en '{scaled_filepath}'")
            return {'FINISHED'}
        except Exception as e:
            self.report({'ERROR'}, f"Error al guardar la imagen: {e}")
            return {'CANCELLED'}

def menu_func(self, context):
    self.layout.operator(OBJECT_OT_scale_and_convert_image.bl_idname)

def register():
    bpy.utils.register_class(OBJECT_OT_scale_and_convert_image)
    bpy.types.VIEW3D_MT_object.append(menu_func)

def unregister():
    bpy.utils.unregister_class(OBJECT_OT_scale_and_convert_image)
    bpy.types.VIEW3D_MT_object.remove(menu_func)

if __name__ == "__main__":
    register()
Cambios Clave
Se han añadido las variables output_format y output_ext al principio de la función execute. Esto te permite definir fácilmente el formato de salida y la extensión deseada.

En la línea que construye el nuevo nombre del archivo, ahora se usa output_ext en lugar de la extensión original.

El formato de renderizado de la escena de Blender (context.scene.render.image_settings.file_format) se establece explícitamente a output_format ('PNG').

Para usarlo, solo tienes que guardar este script como un nuevo archivo .py, instalarlo como addon y, al ejecutarlo, la imagen se reescalará y se guardará como un PNG. Si quisieras otro formato, como JPG, solo tendrías que cambiar los valores de output_format y output_ext al principio del script.






Puedo tener el addon de manera más elegante? Con una interfaz, que me deje elegir ahí el formato de salida de imagen y la ruta


¡Claro! Crear una interfaz de usuario (UI) en Blender para tu addon es la forma más elegante de hacerlo. Esto te permite tener un panel con botones y opciones desplegables donde el usuario puede seleccionar la ruta de guardado y el formato de la imagen, sin necesidad de editar el código.

Aquí está el script completo para un addon con una interfaz de usuario en la barra lateral (N-Panel) del Viewport 3D.

1. El Script con Interfaz (UI)
Copia y pega este código completo en el Editor de Texto de Blender y guárdalo como image_scaler_ui.py.

Python

bl_info = {
    "name": "Image Scaler UI",
    "author": "Tu Nombre",
    "version": (1, 0),
    "blender": (4, 1, 0),
    "location": "3D Viewport > Sidebar",
    "description": "Escala la textura del objeto activo y la guarda con opciones de formato y ruta.",
    "warning": "",
    "wiki_url": "",
    "category": "Object",
}

import bpy
import os

# Define las opciones de formato para el menú desplegable de la UI
image_formats = [
    ('PNG', 'PNG', 'Portable Network Graphics'),
    ('JPEG', 'JPEG', 'Joint Photographic Experts Group'),
    ('TIFF', 'TIFF', 'Tagged Image File Format'),
    ('BMP', 'BMP', 'Bitmap'),
    ('OPEN_EXR', 'OpenEXR', 'High Dynamic Range Image'),
]

# Creamos las propiedades de la escena para guardar las configuraciones de la UI
class ImageScalerProperties(bpy.types.PropertyGroup):
    output_path: bpy.props.StringProperty(
        name="Ruta de Salida",
        subtype='DIR_PATH',
        default="E:\\"
    )
    output_format: bpy.props.EnumProperty(
        name="Formato",
        items=image_formats,
        default='PNG'
    )

# La clase del panel de la UI
class VIEW3D_PT_image_scaler_panel(bpy.types.Panel):
    bl_label = "Escalador de Imágenes"
    bl_idname = "VIEW3D_PT_image_scaler_panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Herramientas"
    
    def draw(self, context):
        layout = self.layout
        scene = context.scene
        props = scene.image_scaler_props
        
        # Muestra las propiedades en la UI
        layout.prop(props, "output_path")
        layout.prop(props, "output_format")
        
        # Botón para ejecutar el operador
        layout.operator("object.scale_and_save_image", text="Escalar y Guardar Imagen")

# El operador que realiza la acción principal
class OBJECT_OT_scale_and_save_image(bpy.types.Operator):
    bl_idname = "object.scale_and_save_image"
    bl_label = "Escalar y Guardar Imagen"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        new_size = (4096, 4096)
        
        # Obtenemos las propiedades de la UI
        props = context.scene.image_scaler_props
        output_path = props.output_path
        output_format = props.output_format
        
        obj = context.active_object
        
        if not obj or obj.type != 'MESH' or not obj.data.materials:
            self.report({'WARNING'}, "El objeto activo no es un MESH o no tiene un material.")
            return {'CANCELLED'}

        material = obj.data.materials[0]
        
        if not material.use_nodes:
            self.report({'WARNING'}, "El material no usa nodos.")
            return {'CANCELLED'}

        image_node = material.node_tree.nodes.get("Image Texture")
        
        if not image_node or not image_node.image:
            self.report({'WARNING'}, "No se encontró el nodo de textura de imagen o no tiene una imagen asignada.")
            return {'CANCELLED'}

        image = image_node.image
        
        try:
            image.scale(new_size[0], new_size[1])
            
            # Obtiene el nombre del archivo sin la extensión
            original_filename = os.path.splitext(image.name)[0]
            
            # Mapea el formato a la extensión del archivo
            ext_map = {item[0]: item[1].lower() for item in image_formats}
            output_ext = '.' + ext_map.get(output_format, 'png')

            scaled_filename = f'scaled_{original_filename}{output_ext}'
            scaled_filepath = os.path.join(output_path, scaled_filename)

            if not os.path.isabs(scaled_filepath):
                scaled_filepath = bpy.path.abspath(scaled_filepath)
            
            context.scene.render.image_settings.file_format = output_format
            
            image.save_render(filepath=scaled_filepath)
            self.report({'INFO'}, f"Imagen '{image.name}' reescalada y convertida a {output_format}, guardada en '{scaled_filepath}'")
            return {'FINISHED'}
        except Exception as e:
            self.report({'ERROR'}, f"Error al guardar la imagen: {e}")
            return {'CANCELLED'}

# Registro de las clases
def register():
    bpy.utils.register_class(ImageScalerProperties)
    bpy.utils.register_class(OBJECT_OT_scale_and_save_image)
    bpy.utils.register_class(VIEW3D_PT_image_scaler_panel)
    bpy.types.Scene.image_scaler_props = bpy.props.PointerProperty(type=ImageScalerProperties)

def unregister():
    bpy.utils.unregister_class(ImageScalerProperties)
    bpy.utils.unregister_class(OBJECT_OT_scale_and_save_image)
    bpy.utils.unregister_class(VIEW3D_PT_image_scaler_panel)
    del bpy.types.Scene.image_scaler_props

if __name__ == "__main__":
    register()
2. Instalar el Addon
Guarda el script en un archivo llamado image_scaler_ui.py.

En Blender, ve a Edit > Preferences > Add-ons.

Haz clic en Install... y selecciona el archivo .py que acabas de guardar.

Activa el addon en la lista marcando la casilla.

3. Usar el Addon
En el Viewport 3D, presiona la tecla N para abrir la barra lateral (N-Panel).

Busca una nueva pestaña llamada "Herramientas" (o el nombre que le hayas dado en la categoría del script).

Dentro de la pestaña, verás el panel "Escalador de Imágenes".

En este panel, puedes:

Hacer clic en el icono de la carpeta para elegir la ruta de salida.

Seleccionar el formato de salida deseado de un menú desplegable.

Hacer clic en el botón "Escalar y Guardar Imagen" para ejecutar la acción.

Este enfoque es mucho más intuitivo para el usuario, ya que no requiere interactuar con el código y te da la flexibilidad que necesitas.







Está genial! Pero acabo de caer, necesito que tambien me pregunte la resolución de la imagen


That's an excellent idea. Adding resolution options to the UI will make the addon even more flexible. We can update the script to include a new setting for resolution and then use that value to scale the image.

Here is the updated script that includes a resolution selector in the UI.

1. The Updated Script
This version adds a new property to the UI where you can choose the image resolution from a dropdown menu.

Python

import bpy
import os

bl_info = {
    "name": "Image Scaler UI",
    "author": "Tu Nombre",
    "version": (1, 1),
    "blender": (4, 1, 0),
    "location": "3D Viewport > Sidebar",
    "description": "Escala la textura del objeto activo con opciones de resolución, formato y ruta.",
    "warning": "",
    "wiki_url": "",
    "category": "Object",
}

# Define las opciones de formato y resolución para la UI
image_formats = [
    ('PNG', 'PNG', 'Portable Network Graphics'),
    ('JPEG', 'JPEG', 'Joint Photographic Experts Group'),
    ('TIFF', 'TIFF', 'Tagged Image File Format'),
    ('BMP', 'BMP', 'Bitmap'),
    ('OPEN_EXR', 'OpenEXR', 'High Dynamic Range Image'),
]

image_resolutions = [
    ('512', '512x512', 'Resolución 512x512'),
    ('1024', '1024x1024', 'Resolución 1024x1024'),
    ('2048', '2048x2048', 'Resolución 2048x2048'),
    ('4096', '4096x4096', 'Resolución 4096x4096'),
    ('8192', '8192x8192', 'Resolución 8192x8192'),
]

# Creamos las propiedades de la escena para guardar las configuraciones de la UI
class ImageScalerProperties(bpy.types.PropertyGroup):
    output_path: bpy.props.StringProperty(
        name="Ruta de Salida",
        subtype='DIR_PATH',
        default="E:\\"
    )
    output_format: bpy.props.EnumProperty(
        name="Formato",
        items=image_formats,
        default='PNG'
    )
    resolution: bpy.props.EnumProperty(
        name="Resolución",
        items=image_resolutions,
        default='4096'
    )

# La clase del panel de la UI
class VIEW3D_PT_image_scaler_panel(bpy.types.Panel):
    bl_label = "Escalador de Imágenes"
    bl_idname = "VIEW3D_PT_image_scaler_panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Herramientas"
    
    def draw(self, context):
        layout = self.layout
        scene = context.scene
        props = scene.image_scaler_props
        
        # Muestra las propiedades en la UI
        layout.prop(props, "output_path")
        layout.prop(props, "output_format")
        layout.prop(props, "resolution")
        
        # Botón para ejecutar el operador
        layout.operator("object.scale_and_save_image", text="Escalar y Guardar Imagen")

# El operador que realiza la acción principal
class OBJECT_OT_scale_and_save_image(bpy.types.Operator):
    bl_idname = "object.scale_and_save_image"
    bl_label = "Escalar y Guardar Imagen"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.image_scaler_props
        
        # Obtenemos la resolución de la UI y la convertimos a entero
        resolution_val = int(props.resolution)
        new_size = (resolution_val, resolution_val)
        
        output_path = props.output_path
        output_format = props.output_format
        
        obj = context.active_object
        
        if not obj or obj.type != 'MESH' or not obj.data.materials:
            self.report({'WARNING'}, "El objeto activo no es un MESH o no tiene un material.")
            return {'CANCELLED'}

        material = obj.data.materials[0]
        
        if not material.use_nodes:
            self.report({'WARNING'}, "El material no usa nodos.")
            return {'CANCELLED'}

        image_node = material.node_tree.nodes.get("Image Texture")
        
        if not image_node or not image_node.image:
            self.report({'WARNING'}, "No se encontró el nodo de textura de imagen o no tiene una imagen asignada.")
            return {'CANCELLED'}

        image = image_node.image
        
        try:
            image.scale(new_size[0], new_size[1])
            
            original_filename = os.path.splitext(image.name)[0]
            
            ext_map = {item[0]: item[1].lower() for item in image_formats}
            output_ext = '.' + ext_map.get(output_format, 'png')

            scaled_filename = f'scaled_{original_filename}_{resolution_val}x{resolution_val}{output_ext}'
            scaled_filepath = os.path.join(output_path, scaled_filename)

            if not os.path.isabs(scaled_filepath):
                scaled_filepath = bpy.path.abspath(scaled_filepath)
            
            context.scene.render.image_settings.file_format = output_format
            
            image.save_render(filepath=scaled_filepath)
            self.report({'INFO'}, f"Imagen reescalada a {resolution_val}x{resolution_val} y guardada en '{scaled_filepath}'")
            return {'FINISHED'}
        except Exception as e:
            self.report({'ERROR'}, f"Error al guardar la imagen: {e}")
            return {'CANCELLED'}

# Registro de las clases
def register():
    bpy.utils.register_class(ImageScalerProperties)
    bpy.utils.register_class(OBJECT_OT_scale_and_save_image)
    bpy.utils.register_class(VIEW3D_PT_image_scaler_panel)
    bpy.types.Scene.image_scaler_props = bpy.props.PointerProperty(type=ImageScalerProperties)

def unregister():
    bpy.utils.unregister_class(ImageScalerProperties)
    bpy.utils.unregister_class(OBJECT_OT_scale_and_save_image)
    bpy.utils.unregister_class(VIEW3D_PT_image_scaler_panel)
    del bpy.types.Scene.image_scaler_props

if __name__ == "__main__":
    register()
2. Cómo Usar el Nuevo Addon
Guarda el script anterior en un archivo .py (puedes sobrescribir el anterior o guardarlo con un nuevo nombre como image_scaler_v1_1.py).

Instala o actualiza el addon en Blender:

Si usas el mismo nombre de archivo, ve a Edit > Preferences > Add-ons, busca tu addon y haz clic en el botón Refresh y luego activa la casilla.

Si lo guardas con un nombre nuevo, simplemente Instala... el nuevo archivo como lo hiciste antes.

En la barra lateral (N-Panel) del Viewport 3D, verás el nuevo menú desplegable de "Resolución" con las opciones que definimos en el script.

Ahora tienes una herramienta completa que te permite elegir el tamaño y el formato de la imagen de salida, haciendo tu flujo de trabajo mucho más eficiente y elegante.
